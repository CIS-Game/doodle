<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ù–∞–π–¥–∏ –î—É–±–ª—å üëë –ö–æ–Ω–∫—É—Ä—Å –ö—Ä–∞—Å–æ—Ç—ã</title>
    <style>
        body {
            margin: 0;
            padding: 15px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #ff9a9e, #fecfef, #fad0c4);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: manipulation;
        }
        canvas {
            border: 4px solid #ffd1dc;
            border-radius: 25px;
            background: linear-gradient(45deg, #fff0f5, #ffe4e1);
            box-shadow: 0 15px 35px rgba(255,182,193,0.4);
            max-width: 95vw;
            max-height: 75vh;
            touch-action: manipulation;
        }
        .ui {
            margin: 10px 0;
            font-size: 14px;
            font-weight: bold;
            color: #c71585;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stats {
            background: rgba(255,255,255,0.9);
            padding: 8px 15px;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(255,105,180,0.3);
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 25px;
            text-align: center;
            font-size: 24px;
            color: #dc143c;
            border: 4px solid #ff69b4;
            box-shadow: 0 10px 25px rgba(220,20,60,0.3);
        }
        button {
            background: linear-gradient(45deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 6px 15px rgba(255,105,180,0.4);
            font-weight: bold;
        }
        button:hover, button:active {
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="ui">
        <div class="stats">‚≠ê –ë–∞–ª–ª—ã: <span id="score">0</span></div>
        <div class="stats">‚è±Ô∏è –í—Ä–µ–º—è: <span id="time">0</span>—Å</div>
        <div class="stats">üëë –ü–∞—Ä: <span id="pairs">0</span>/24</div>
    </div>
    <canvas id="gameCanvas" width="450" height="550"></canvas>
    <div id="gameOver" class="game-over" style="display: none;">
        <div>–ü–æ–±–µ–¥–∞! üëë‚ú®</div>
        <div>–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á—ë—Ç: <span id="finalScore">0</span> ‚≠ê</div>
        <button onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞ üëó</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const timeEl = document.getElementById('time');
        const pairsEl = document.getElementById('pairs');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');

        // –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        let score = 0;
        let timeElapsed = 0;
        let gameRunning = true;
        let grid = [];
        let selected = [];
        let tiles = [];
        let cols = 6;
        let rows = 8;
        let tileSize = 78; // +30% (–±—ã–ª–æ 60)
        let timer;
        let totalPairs = (cols * rows) / 2;
        let isProcessing = false; // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –≤—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏

        // –≠–º–æ–¥–∑–∏ –¥–ª—è –∫–æ–Ω–∫—É—Ä—Å–∞ –∫—Ä–∞—Å–æ—Ç—ã
        const beautyEmojis = ['üëó', 'üë†', 'üíÑ', 'üëë', 'üåπ', 'üíç', 'üíÖ', '‚≠ê', '‚ú®', 'üíñ', 'üéÄ', 'üëú'];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ç–∫–∏
        function initGrid() {
            grid = [];
            tiles = [];
            const emojis = [];
            
            for (let i = 0; i < totalPairs; i++) {
                const emoji = beautyEmojis[Math.floor(Math.random() * beautyEmojis.length)];
                emojis.push(emoji, emoji);
            }
            
            for (let i = emojis.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [emojis[i], emojis[j]] = [emojis[j], emojis[i]];
            }
            
            let index = 0;
            for (let row = 0; row < rows; row++) {
                grid[row] = [];
                for (let col = 0; col < cols; col++) {
                    grid[row][col] = emojis[index++];
                    tiles.push({
                        row: row,
                        col: col,
                        emoji: grid[row][col],
                        x: col * tileSize + 12,
                        y: row * tileSize + 15,
                        width: tileSize,
                        height: tileSize,
                        visible: false,
                        matched: false
                    });
                }
            }
        }

        // –ó–≤—É–∫–∏
        function playSound(frequency, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch(e) {}
        }

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –§–æ–Ω —Å –±–ª–µ—Å–∫–æ–º
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // –ó–∞–≥–æ–ª–æ–≤–æ–∫
            ctx.fillStyle = '#c71585';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('–ù–∞–π–¥–∏ –ø–∞—Ä—É! üëó‚ú®', canvas.width / 2, 12);

            // –ü–ª–∏—Ç–∫–∏
            tiles.forEach(tile => {
                const x = tile.x;
                const y = tile.y;
                
                ctx.strokeStyle = tile.visible ? '#ffd700' : '#ddd';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, tile.width, tile.height);
                
                if (selected.some(s => s.row === tile.row && s.col === tile.col)) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                    ctx.fillRect(x + 4, y + 4, tile.width - 8, tile.height - 8);
                }
                
                if (tile.visible || tile.matched) {
                    ctx.font = '62px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(tile.emoji, x + tile.width / 2, y + tile.height / 2);
                } else {
                    ctx.fillStyle = 'rgba(255, 182, 193, 0.85)';
                    ctx.fillRect(x + 8, y + 8, tile.width - 16, tile.height - 16);
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '52px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚≠ê', x + tile.width / 2, y + tile.height / 2);
                }
            });
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
        function checkMatch() {
            if (selected.length === 2) {
                const tile1 = tiles.find(t => t.row === selected[0].row && t.col === selected[0].col);
                const tile2 = tiles.find(t => t.row === selected[1].row && t.col === selected[1].col);
                
                if (tile1.emoji === tile2.emoji) {
                    tile1.matched = true;
                    tile2.matched = true;
                    score += Math.max(50, 100 - (timeElapsed * 0.5));
                    scoreEl.textContent = Math.floor(score);
                    playSound(800, 0.2);
                    
                    // –°—Ä–∞–∑—É –∑–∞–∫—Ä—ã–≤–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–±–µ–¥—É
                    tiles.forEach(tile => {
                        if (!tile.matched) tile.visible = false;
                    });
                    selected = [];
                    isProcessing = false;
                    updatePairs();
                    checkWin();
                } else {
                    playSound(200, 0.3);
                    setTimeout(() => {
                        tiles.forEach(tile => {
                            if (!tile.matched) tile.visible = false;
                        });
                        selected = [];
                        isProcessing = false;
                        draw();
                    }, 400); // –ë—ã—Å—Ç—Ä–µ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ
                }
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á—ë—Ç—á–∏–∫–∞ –ø–∞—Ä
        function updatePairs() {
            const matchedCount = tiles.filter(tile => tile.matched).length / 2;
            pairsEl.textContent = matchedCount;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã
        function checkWin() {
            const matchedCount = tiles.filter(tile => tile.matched).length / 2;
            if (matchedCount === totalPairs) {
                score += Math.max(500, 1000 - (timeElapsed * 2));
                scoreEl.textContent = Math.floor(score);
                endGame();
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ (–º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Ä–µ–∞–∫—Ü–∏—è)
        function handleClick(clientX, clientY) {
            if (!gameRunning || isProcessing || selected.length >= 2) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            const col = Math.floor(x / tileSize);
            const row = Math.floor((y - 15) / tileSize);
            
            if (col >= 0 && col < cols && row >= 0 && row < rows) {
                const tile = tiles.find(t => t.row === row && t.col === col);
                if (tile && !tile.matched && !tile.visible) {
                    tile.visible = true;
                    selected.push({row, col});
                    isProcessing = true;
                    draw();
                    
                    if (selected.length === 2) {
                        setTimeout(checkMatch, 200); // –û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ
                    }
                }
            }
        }

        // –¢–∞–π–º–µ—Ä
        function startTimer() {
            timer = setInterval(() => {
                timeElapsed++;
                timeEl.textContent = timeElapsed;
            }, 1000);
        }

        function endGame() {
            gameRunning = false;
            clearInterval(timer);
            finalScoreEl.textContent = Math.floor(score);
            gameOverEl.style.display = 'block';
        }

        function restartGame() {
            score = 0;
            timeElapsed = 0;
            gameRunning = true;
            selected = [];
            isProcessing = false;
            scoreEl.textContent = score;
            timeEl.textContent = timeElapsed;
            pairsEl.textContent = '0';
            gameOverEl.style.display = 'none';
            clearInterval(timer);
            initGrid();
            draw();
            startTimer();
        }

        // –°–æ–±—ã—Ç–∏—è
        canvas.addEventListener('click', (e) => handleClick(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleClick(touch.clientX, touch.clientY);
        }, { passive: false });

        // –°—Ç–∞—Ä—Ç –∏–≥—Ä—ã
        initGrid();
        draw();
        startTimer();
    </script>
</body>
</html>
