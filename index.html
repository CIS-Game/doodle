<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ù–∞–π–¥–∏ –î—É–±–ª—å üëë –ö–æ–Ω–∫—É—Ä—Å –ö—Ä–∞—Å–æ—Ç—ã</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #ff9a9e, #fecfef, #fad0c4);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: manipulation;
        }
        canvas {
            border: 4px solid #ffd1dc;
            border-radius: 25px;
            background: linear-gradient(45deg, #fff0f5, #ffe4e1);
            box-shadow: 0 15px 35px rgba(255,182,193,0.4);
            max-width: 95vw;
            max-height: 70vh;
            touch-action: manipulation;
        }
        .ui {
            margin: 15px 0;
            font-size: 28px;
            font-weight: bold;
            color: #c71585;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            display: flex;
            gap: 30px;
        }
        .stats {
            background: rgba(255,255,255,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(255,105,180,0.3);
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            font-size: 32px;
            color: #dc143c;
            border: 5px solid #ff69b4;
            box-shadow: 0 10px 30px rgba(220,20,60,0.3);
        }
        button {
            background: linear-gradient(45deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            padding: 18px 35px;
            font-size: 22px;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 8px 20px rgba(255,105,180,0.4);
            font-weight: bold;
        }
        button:hover, button:active {
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            transform: translateY(-2px);
        }
        .selected {
            background: rgba(255,215,0,0.3) !important;
            border: 3px solid #ffd700 !important;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="ui">
        <div class="stats">‚≠ê –ë–∞–ª–ª—ã: <span id="score">0</span></div>
        <div class="stats">‚è±Ô∏è –í—Ä–µ–º—è: <span id="time">0</span>—Å</div>
        <div class="stats">üëë –ù–∞–π–¥–µ–Ω–æ –ø–∞—Ä: <span id="pairs">0</span>/24</div>
    </div>
    <canvas id="gameCanvas" width="450" height="550"></canvas>
    <div id="gameOver" class="game-over" style="display: none;">
        <div>–ü–æ–±–µ–¥–∞! üëë‚ú®</div>
        <div>–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á—ë—Ç: <span id="finalScore">0</span> ‚≠ê</div>
        <button onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞ üëó</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const timeEl = document.getElementById('time');
        const pairsEl = document.getElementById('pairs');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');

        // –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        let score = 0;
        let timeElapsed = 0;
        let gameRunning = true;
        let grid = [];
        let selected = [];
        let tiles = [];
        let cols = 6;
        let rows = 8;
        let tileSize = 60;
        let timer;
        let totalPairs = (cols * rows) / 2;

        // –≠–º–æ–¥–∑–∏ –¥–ª—è –∫–æ–Ω–∫—É—Ä—Å–∞ –∫—Ä–∞—Å–æ—Ç—ã
        const beautyEmojis = ['üëó', 'üë†', 'üíÑ', 'üëë', 'üåπ', 'üíç', 'üíÖ', '‚≠ê', '‚ú®', 'üíñ', 'üéÄ', 'üëú'];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ç–∫–∏
        function initGrid() {
            grid = [];
            tiles = [];
            const emojis = [];
            
            // –°–æ–∑–¥–∞–µ–º –ø–∞—Ä—ã —ç–º–æ–¥–∑–∏
            for (let i = 0; i < totalPairs; i++) {
                const emoji = beautyEmojis[Math.floor(Math.random() * beautyEmojis.length)];
                emojis.push(emoji, emoji);
            }
            
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º
            for (let i = emojis.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [emojis[i], emojis[j]] = [emojis[j], emojis[i]];
            }
            
            // –°–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É
            let index = 0;
            for (let row = 0; row < rows; row++) {
                grid[row] = [];
                for (let col = 0; col < cols; col++) {
                    grid[row][col] = emojis[index++];
                    tiles.push({
                        row: row,
                        col: col,
                        emoji: grid[row][col],
                        x: col * tileSize + 15,
                        y: row * tileSize + 20,
                        width: tileSize,
                        height: tileSize,
                        visible: false,
                        matched: false
                    });
                }
            }
        }

        // –ó–≤—É–∫–∏
        function playSound(frequency, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch(e) {}
        }

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –§–æ–Ω —Å –±–ª–µ—Å–∫–æ–º
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // –ó–∞–≥–æ–ª–æ–≤–æ–∫
            ctx.fillStyle = '#c71585';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('–ù–∞–π–¥–∏ –ø–∞—Ä—É! üëó‚ú®', canvas.width / 2, 15);

            // –ü–ª–∏—Ç–∫–∏
            tiles.forEach(tile => {
                const x = tile.x;
                const y = tile.y;
                
                // –†–∞–º–∫–∞ –ø–ª–∏—Ç–∫–∏
                ctx.strokeStyle = tile.visible ? '#ffd700' : '#ddd';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, tile.width, tile.height);
                
                // –í—ã–±—Ä–∞–Ω–Ω–∞—è –ø–ª–∏—Ç–∫–∞
                if (selected.some(s => s.row === tile.row && s.col === tile.col)) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.fillRect(x + 3, y + 3, tile.width - 6, tile.height - 6);
                }
                
                // –≠–º–æ–¥–∑–∏ –∏–ª–∏ –∑–≤—ë–∑–¥–æ—á–∫–∞
                if (tile.visible || tile.matched) {
                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(tile.emoji, x + tile.width / 2, y + tile.height / 2);
                } else {
                    // –ó–≤—ë–∑–¥–æ—á–∫–∞ ‚≠ê –≤–º–µ—Å—Ç–æ "?"
                    ctx.fillStyle = 'rgba(255, 182, 193, 0.8)';
                    ctx.fillRect(x + 8, y + 8, tile.width - 16, tile.height - 16);
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '40px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚≠ê', x + tile.width / 2, y + tile.height / 2);
                }
            });
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π (–º–∞–∫—Å–∏–º—É–º 2 –∫–∞—Ä—Ç–æ—á–∫–∏)
        function checkMatch() {
            if (selected.length === 2) {
                const tile1 = tiles.find(t => t.row === selected[0].row && t.col === selected[0].col);
                const tile2 = tiles.find(t => t.row === selected[1].row && t.col === selected[1].col);
                
                if (tile1.emoji === tile2.emoji) {
                    // –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ!
                    tile1.matched = true;
                    tile2.matched = true;
                    score += 100 - (timeElapsed * 0.5); // –ë–æ–ª—å—à–µ –æ—á–∫–æ–≤ = –±—ã—Å—Ç—Ä–µ–µ –Ω–∞–π–¥–µ–Ω–æ
                    scoreEl.textContent = Math.floor(score);
                    pairsEl.textContent = tiles.filter(t => t.matched).length / 2;
                    playSound(800, 0.3);
                    
                    selected = [];
                    checkWin();
                } else {
                    // –ù–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç - –∑–∞–∫—Ä—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ —Å–µ–∫—É–Ω–¥—É
                    playSound(200, 0.4);
                    setTimeout(() => {
                        tiles.forEach(tile => {
                            if (!tile.matched) tile.visible = false;
                        });
                        selected = [];
                        draw();
                    }, 1000);
                }
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã
        function checkWin() {
            const matchedCount = tiles.filter(tile => tile.matched).length / 2;
            pairsEl.textContent = matchedCount;
            
            if (matchedCount === totalPairs) {
                score += 1000 - (timeElapsed * 2); // –ë–æ–Ω—É—Å –∑–∞ –ø–æ–±–µ–¥—É
                scoreEl.textContent = Math.floor(score);
                endGame();
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ (–º–∞–∫—Å–∏–º—É–º 2 –æ—Ç–∫—Ä—ã—Ç—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏)
        function handleClick(clientX, clientY) {
            if (!gameRunning || selected.length >= 2) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            const col = Math.floor(x / tileSize);
            const row = Math.floor((y - 20) / tileSize);
            
            if (col >= 0 && col < cols && row >= 0 && row < rows) {
                const tile = tiles.find(t => t.row === row && t.col === col);
                if (!tile.matched && !tile.visible) {
                    tile.visible = true;
                    selected.push({row, col});
                    draw();
                    
                    if (selected.length === 2) {
                        setTimeout(checkMatch, 600);
                    }
                }
            }
        }

        // –¢–∞–π–º–µ—Ä (–≤—Ä–µ–º—è —Ä–∞—Å—Ç—ë—Ç)
        function startTimer() {
            timer = setInterval(() => {
                timeElapsed++;
                timeEl.textContent = timeElapsed;
            }, 1000);
        }

        function endGame() {
            gameRunning = false;
            clearInterval(timer);
            finalScoreEl.textContent = Math.floor(score);
            gameOverEl.style.display = 'block';
        }

        function restartGame() {
            score = 0;
            timeElapsed = 0;
            gameRunning = true;
            selected = [];
            scoreEl.textContent = score;
            timeEl.textContent = timeElapsed;
            pairsEl.textContent = '0';
            gameOverEl.style.display = 'none';
            clearInterval(timer);
            initGrid();
            draw();
            startTimer();
        }

        // –°–æ–±—ã—Ç–∏—è
        canvas.addEventListener('click', (e) => handleClick(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleClick(touch.clientX, touch.clientY);
        });

        // –°—Ç–∞—Ä—Ç –∏–≥—Ä—ã
        initGrid();
        draw();
        startTimer();
    </script>
</body>
</html>
